// Code generated by fixtory; DO NOT EDIT.

package example

import (
	"testing"

	"github.com/k-yomo/fixtory"
)

type AuthorTrait struct {
	Author Author
	Zero   []AuthorField
}

type AuthorFactory interface {
	NewBuilder(bluePrint AuthorBluePrintFunc, traits ...AuthorTrait) AuthorBuilder
	OnBuild(onBuild func(t *testing.T, author *Author))
	Reset()
}

type AuthorBuilder interface {
	EachParam(authorParams ...AuthorTrait) AuthorBuilder
	Set(author Author) AuthorBuilder
	Zero(authorFields ...AuthorField) AuthorBuilder
	ResetAfter() AuthorBuilder

	Build() *Author
	Build2() (*Author, *Author)
	Build3() (*Author, *Author, *Author)
	BuildList(n int) []*Author
}

type AuthorBluePrintFunc func(i int, last Author) Author

type AuthorField string

const (
	AuthorIDField   AuthorField = "ID"
	AuthorNameField AuthorField = "Name"
)

type authorFactory struct {
	t       *testing.T
	factory *fixtory.Factory
}

type authorBuilder struct {
	t       *testing.T
	builder *fixtory.Builder
}

func NewAuthorFactory(t *testing.T) AuthorFactory {
	t.Helper()

	return &authorFactory{t: t, factory: fixtory.NewFactory(t, Author{})}
}

func (uf *authorFactory) NewBuilder(bluePrint AuthorBluePrintFunc, traits ...AuthorTrait) AuthorBuilder {
	uf.t.Helper()

	var bp fixtory.BluePrintFunc
	if bluePrint != nil {
		bp = func(i int, last interface{}) interface{} { return bluePrint(i, last.(Author)) }
	}

	traitStructs := make([]Author, len(traits))
	traitZeroes := make([][]string, len(traits))

	for i := range traits {
		traitStructs[i] = traits[i].Author

		fields := make([]string, 0, len(traits[i].Zero))
		for _, f := range traits[i].Zero {
			fields = append(fields, string(f))
		}
		traitZeroes[i] = fields
	}

	builder := uf.factory.NewBuilder(bp, fixtory.ConvertToInterfaceArray(traitStructs), traitZeroes)
	return &authorBuilder{t: uf.t, builder: builder}
}

func (uf *authorFactory) OnBuild(onBuild func(t *testing.T, author *Author)) {
	uf.t.Helper()

	uf.factory.OnBuild = func(t *testing.T, v interface{}) { onBuild(t, v.(*Author)) }
}

func (uf *authorFactory) Reset() {
	uf.t.Helper()

	uf.factory.Reset()
}

func (ub *authorBuilder) Set(author Author) AuthorBuilder {
	ub.t.Helper()

	ub.builder = ub.builder.Set(author)
	return ub
}

func (ub *authorBuilder) Zero(authorFields ...AuthorField) AuthorBuilder {
	ub.t.Helper()

	fields := make([]string, 0, len(authorFields))
	for _, f := range authorFields {
		fields = append(fields, string(f))
	}

	ub.builder = ub.builder.Zero(fields...)
	return ub
}
func (ub *authorBuilder) ResetAfter() AuthorBuilder {
	ub.t.Helper()

	ub.builder = ub.builder.ResetAfter()
	return ub
}

func (ub *authorBuilder) EachParam(authorParams ...AuthorTrait) AuthorBuilder {
	ub.t.Helper()

	traitStructs := make([]Author, len(authorParams))
	traitZeroes := make([][]string, len(authorParams))

	for i := range authorParams {
		traitStructs[i] = authorParams[i].Author

		fields := make([]string, 0, len(authorParams[i].Zero))
		for _, f := range authorParams[i].Zero {
			fields = append(fields, string(f))
		}
		traitZeroes[i] = fields
	}

	ub.builder = ub.builder.EachParam(fixtory.ConvertToInterfaceArray(traitStructs), traitZeroes)
	return ub
}

func (ub *authorBuilder) Build() *Author {
	ub.t.Helper()

	return ub.builder.Build().(*Author)
}

func (ub *authorBuilder) Build2() (*Author, *Author) {
	ub.t.Helper()

	list := ub.BuildList(2)
	return list[0], list[1]
}

func (ub *authorBuilder) Build3() (*Author, *Author, *Author) {
	ub.t.Helper()

	list := ub.BuildList(3)
	return list[0], list[1], list[2]
}

func (ub *authorBuilder) BuildList(n int) []*Author {
	ub.t.Helper()

	list := make([]*Author, 0, n)
	for _, v := range ub.builder.BuildList(n) {
		list = append(list, v.(*Author))
	}
	return list
}

type ArticleTrait struct {
	Article Article
	Zero    []ArticleField
}

type ArticleFactory interface {
	NewBuilder(bluePrint ArticleBluePrintFunc, traits ...ArticleTrait) ArticleBuilder
	OnBuild(onBuild func(t *testing.T, article *Article))
	Reset()
}

type ArticleBuilder interface {
	EachParam(articleParams ...ArticleTrait) ArticleBuilder
	Set(article Article) ArticleBuilder
	Zero(articleFields ...ArticleField) ArticleBuilder
	ResetAfter() ArticleBuilder

	Build() *Article
	Build2() (*Article, *Article)
	Build3() (*Article, *Article, *Article)
	BuildList(n int) []*Article
}

type ArticleBluePrintFunc func(i int, last Article) Article

type ArticleField string

const (
	ArticleIDField                 ArticleField = "ID"
	ArticleTitleField              ArticleField = "Title"
	ArticleBodyField               ArticleField = "Body"
	ArticleAuthorIDField           ArticleField = "AuthorID"
	ArticlePublishScheduledAtField ArticleField = "PublishScheduledAt"
	ArticlePublishedAtField        ArticleField = "PublishedAt"
	ArticleStatusField             ArticleField = "Status"
	ArticleLikeCountField          ArticleField = "LikeCount"
)

type articleFactory struct {
	t       *testing.T
	factory *fixtory.Factory
}

type articleBuilder struct {
	t       *testing.T
	builder *fixtory.Builder
}

func NewArticleFactory(t *testing.T) ArticleFactory {
	t.Helper()

	return &articleFactory{t: t, factory: fixtory.NewFactory(t, Article{})}
}

func (uf *articleFactory) NewBuilder(bluePrint ArticleBluePrintFunc, traits ...ArticleTrait) ArticleBuilder {
	uf.t.Helper()

	var bp fixtory.BluePrintFunc
	if bluePrint != nil {
		bp = func(i int, last interface{}) interface{} { return bluePrint(i, last.(Article)) }
	}

	traitStructs := make([]Article, len(traits))
	traitZeroes := make([][]string, len(traits))

	for i := range traits {
		traitStructs[i] = traits[i].Article

		fields := make([]string, 0, len(traits[i].Zero))
		for _, f := range traits[i].Zero {
			fields = append(fields, string(f))
		}
		traitZeroes[i] = fields
	}

	builder := uf.factory.NewBuilder(bp, fixtory.ConvertToInterfaceArray(traitStructs), traitZeroes)
	return &articleBuilder{t: uf.t, builder: builder}
}

func (uf *articleFactory) OnBuild(onBuild func(t *testing.T, article *Article)) {
	uf.t.Helper()

	uf.factory.OnBuild = func(t *testing.T, v interface{}) { onBuild(t, v.(*Article)) }
}

func (uf *articleFactory) Reset() {
	uf.t.Helper()

	uf.factory.Reset()
}

func (ub *articleBuilder) Set(article Article) ArticleBuilder {
	ub.t.Helper()

	ub.builder = ub.builder.Set(article)
	return ub
}

func (ub *articleBuilder) Zero(articleFields ...ArticleField) ArticleBuilder {
	ub.t.Helper()

	fields := make([]string, 0, len(articleFields))
	for _, f := range articleFields {
		fields = append(fields, string(f))
	}

	ub.builder = ub.builder.Zero(fields...)
	return ub
}
func (ub *articleBuilder) ResetAfter() ArticleBuilder {
	ub.t.Helper()

	ub.builder = ub.builder.ResetAfter()
	return ub
}

func (ub *articleBuilder) EachParam(articleParams ...ArticleTrait) ArticleBuilder {
	ub.t.Helper()

	traitStructs := make([]Article, len(articleParams))
	traitZeroes := make([][]string, len(articleParams))

	for i := range articleParams {
		traitStructs[i] = articleParams[i].Article

		fields := make([]string, 0, len(articleParams[i].Zero))
		for _, f := range articleParams[i].Zero {
			fields = append(fields, string(f))
		}
		traitZeroes[i] = fields
	}

	ub.builder = ub.builder.EachParam(fixtory.ConvertToInterfaceArray(traitStructs), traitZeroes)
	return ub
}

func (ub *articleBuilder) Build() *Article {
	ub.t.Helper()

	return ub.builder.Build().(*Article)
}

func (ub *articleBuilder) Build2() (*Article, *Article) {
	ub.t.Helper()

	list := ub.BuildList(2)
	return list[0], list[1]
}

func (ub *articleBuilder) Build3() (*Article, *Article, *Article) {
	ub.t.Helper()

	list := ub.BuildList(3)
	return list[0], list[1], list[2]
}

func (ub *articleBuilder) BuildList(n int) []*Article {
	ub.t.Helper()

	list := make([]*Article, 0, n)
	for _, v := range ub.builder.BuildList(n) {
		list = append(list, v.(*Article))
	}
	return list
}
